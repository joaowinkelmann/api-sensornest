// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  name         String?
  insDthr      DateTime @default(now()) @map("ins_dthr")
  altDthr      DateTime @updatedAt @map("alt_dthr")
  passwordHash String   @map("password_hash")

  meshes Mesh[]

  @@map("user")
}

model Mesh {
  id      String   @id @default(uuid())
  name    String
  insDthr DateTime @default(now()) @map("ins_dthr")
  altDthr DateTime @updatedAt @map("alt_dthr")

  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Uma Mesh tem várias Zonas
  zones Zone[]

  @@map("mesh")
}

// Representa uma área poligonal específica dentro de uma Mesh para agrupar dispositivos
model Zone {
  id      String   @id @default(uuid())
  name    String
  insDthr DateTime @default(now()) @map("ins_dthr")
  altDthr DateTime @updatedAt @map("alt_dthr")

  // Vértices que definem a forma do polígono em um mapa virtual.
  // Armazenado como JSON para ser flexível, por exemplo, [{ "x": 0, "y": 50 }, { "x": 100, "y": 50 }, ...]
  vertices Json

  // Cada Zone pertence a uma Mesh somente
  meshId String @map("mesh_id")
  mesh   Mesh   @relation(fields: [meshId], references: [id], onDelete: Cascade)

  // Os dispositvos pertenecem a uma Zone
  workers     Worker[]
  controllers Controller[]

  @@map("zone")
}

model Controller {
  id          String   @id @default(uuid())
  insDthr     DateTime @default(now()) @map("ins_dthr")
  altDthr     DateTime @updatedAt @map("alt_dthr")
  macAddress  String   @unique @map("mac_address")
  name        String
  description String?

  x Float
  y Float

  status DeviceStatus @default(PENDING)

  zoneId String? @map("zone_id")
  zone   Zone?   @relation(fields: [zoneId], references: [id], onDelete: SetNull)

  readings Reading[]

  @@map("controller")
}

model Worker {
  id          String   @id @default(uuid())
  insDthr     DateTime @default(now()) @map("ins_dthr")
  altDthr     DateTime @updatedAt @map("alt_dthr")
  macAddress  String   @unique @map("mac_address")
  name        String
  description String?

  x Float
  y Float

  status DeviceStatus @default(PENDING)

  zoneId String? @map("zone_id")
  zone   Zone?   @relation(fields: [zoneId], references: [id], onDelete: SetNull)

  readings Reading[]

  @@map("worker")
}

// Representa uma leitura de sensores
model Reading {
  id          String   @id @default(uuid())
  insDthr     DateTime @default(now()) @map("ins_dthr")
  altDthr     DateTime @updatedAt @map("alt_dthr")
  temperature Float?
  humidity    Float?
  readingTime DateTime @map("reading_time")

  // Uma leitura pode ser associada tanto a um Worker quanto a um Controller
  workerId String?
  worker   Worker? @relation(fields: [workerId], references: [id], onDelete: Cascade)

  controllerId String?
  controller   Controller? @relation(fields: [controllerId], references: [id], onDelete: Cascade)

  @@map("reading")
}

enum DeviceStatus {
  PENDING // Aguardando ativação/configuração após recém descoberto e adicionado à Mesh automaticamente.
  ACTIVE // Configurado e enviando dados.
  DISABLED // Manualmente desativado
}
